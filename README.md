# tww (Tokio + WebGPU + Winit)

This is a highly opinionated library that you use when you want to use `tokio`, `wgpu`, and `winit`. You interact with `winit` exclusively through async/await so that you never have to worry about event loops again. It will automatically take care of recreating the window surface and rendering resources at the correct times based on the application lifecycle so that you don't need to worry about these details. You provide what capabilities you need to do your rendering and it will take care of the rest.

## Why?

Every operating system works subtly differently. If you look at the `wgpu` examples, it is clear that the majority of the complexity in their examples was [moved out into a separate module called `framework`](https://github.com/gfx-rs/wgpu/blob/v0.20.0/examples/src/framework.rs). This is all good, but if you want to do lots of async/await code like client/server interaction in addition to this you cannot trivially integrate async/await into mix. The `framework` module they provide is based around a sequential synchronous event based model. In fact, they even attempt to hide some of the async parts of `wgpu` in `init_async` and [block the async `start` function with the event loop](https://github.com/gfx-rs/wgpu/blob/v0.20.0/examples/src/framework.rs#L390), which would cause any async application to stop working if this was executed on an async runtime. Furthermore, it is actually important that this is not executed on a multithreaded runtime due to the fact that the main window must be created on the main thread on specific platforms. If you try to integrate this code into anything async, you will find that the two worlds collide and cannot mix. `winit` is [moving away from giving you an event stream](https://docs.rs/winit/0.30.0/winit/#event-handling) to execute on as well since this is not possible on certain systems like web and iOS. Since `winit` doesn't have async infrastructure built-in, people wanting to use async are left without a clear answer.

This crate attempts to bridge the two worlds. It tells `winit` that it is an application and creates the `EventLoop` internally. The events are handled internally where possible, and events relevant to your actual application are accessible through async/await APIs. Particularly as it relates to GPUs, it is only possible to get the `wgpu::Surface` for the main window on certain platforms (e.g. Windows) from the main thread, otherwise it will fail. Coincidentally, due to the way `winit` works, the main thread is also the thread that the `ApplicationHandler` must run on, which cannot be async. To reconcile this, this library handles the extraction of the window surface behind the scenes, and will match the color settings that you ask for as best as possible, similarly to the `wgpu` examples.

Internal tasks are spawned by this library to manage various resources, similar to the concept of actors, but with unfettered async/await access, so workers would probably be a better term. This could be split out into its own library potentially. The tasks use `tokio` primitives to communicate, but this is all hidden from the user. Since it could be possible to use the `futures` crate instead and there isn't a strong reliance on `tokio` specifically, the runtime could be made swappable. For this reason, `tokio` is an optional feature which is enabled by default, but for the time being there is no alternative and compilation will fail otherwise. Currently, only the multi-threaded runtime is used and supported. Using the non-multithreaded runtime could be possible, but would need to be operated on a thread outside the main thread for the time being to avoid conflicting with `winit`. It may be possible to implement a single-threaded executor that runs through `winit` exclusively to better support iOS and web, and this feature will be under consideration.


